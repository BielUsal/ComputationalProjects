{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "using LinearAlgebra\n",
    "using Unitful\n",
    "using UnitfulAstro\n",
    "using OrdinaryDiffEq\n",
    "using Plots\n",
    "using FLoops\n",
    "using Distributed\n",
    "#include(\"./GalaxyCollisionFunctions.jl\")\n",
    "addprocs(4)\n",
    "theme(:dracula)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "evolve_two_disks (generic function with 4 methods)"
      ]
     },
     "execution_count": 2,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "const G = 4.3009E-3 *1u\"pc *(km/s)^2 /Msun\"\n",
    "function format_parameters(galaxy_args)\n",
    "    #I didn't have this at first, but this makes all galaxies have an uniform format. Not too crazy\n",
    "    return Dict(\n",
    "        \"mass\" => galaxy_args[1]*1u\"Msun\",\n",
    "        \"radius\"     => galaxy_args[2]*1u\"kpc\",\n",
    "        \"center_pos\" => galaxy_args[3].*1u\"kpc\",\n",
    "        \"center_vel\" => galaxy_args[4].*1u\"km/s\",\n",
    "        \"normal\"     => galaxy_args[5],\n",
    "        \"Nᵣ\"    => galaxy_args[6],\n",
    "        \"Nₛ\"    => galaxy_args[7],\n",
    "        \"softening\"  => galaxy_args[8]\n",
    "    )\n",
    "end\n",
    "function init_disk!(galaxy,dT=1E-4u\"yr\")\n",
    "    #=\n",
    "    This function takes a 'galaxy' as an argument, which is an array of 8 arguments=>\n",
    "        [mass,radius,center_pos,center_vel,normal,N_rings,N_stars,softening]\n",
    "    And outputs the star positions, velocities and the velocity scale.\n",
    "    =#\n",
    "    dr = (1-galaxy[\"softening\"]) * galaxy[\"radius\"]/galaxy[\"Nᵣ\"] # Disregarding the softening, this is just the width of the rings(raidus/number of slices)\n",
    "    StarsPerRing = trunc(Int64,galaxy[\"Nₛ\"]/galaxy[\"Nᵣ\"])\n",
    "#-------------------------------------------------------------Rotations--------------------------------------------------------------\n",
    "    if norm(galaxy[\"normal\"]) == 0 \n",
    "        Rotation = I\n",
    "    else \n",
    "        cosθ = normalize(galaxy[\"normal\"])[3]\n",
    "        sinθ = √(1-cosθ^2)\n",
    "        u = [0,0,1] × normalize(galaxy[\"normal\"])\n",
    "        if norm(u) == 0 \n",
    "            Rotation = I\n",
    "        else \n",
    "         u = normalize(u)\n",
    "\n",
    "        Rotation = [\n",
    "            u[1]*u[1]*(1-cosθ)+cosθ u[1]*u[2]*(1-cosθ)-u[2]*sinθ u[1]*u[3]*(1-cosθ)+u[1]*sinθ;\n",
    "\n",
    "            u[2]*u[1]*(1-cosθ)+u[3]*sinθ u[2]*u[2]*(1-cosθ)+cosθ u[2]*u[3]*(1-cosθ)-u[1]*sinθ;\n",
    "\n",
    "            u[3]*u[1]*(1-cosθ)+u[2]*sinθ u[3]*u[1]*(1-cosθ)+u[1]*sinθ u[3]*u[3]*(1-cosθ)+cosθ\n",
    "            ]\n",
    "        end\n",
    "    end\n",
    "#-----------------------------------------------------------------------------------------------------------------------------------\n",
    "    galaxy[\"star_pos\"] = []\n",
    "    galaxy[\"star_vel\"] = []\n",
    "\n",
    "    R = galaxy[\"softening\"] * galaxy[\"radius\"]\n",
    "    for i ∈ 1:galaxy[\"Nᵣ\"] #iterate over the rings\n",
    "        #Randomly distribute the initial radii and angles \n",
    "        rₛ =(R * ones(StarsPerRing) + dr *rand(StarsPerRing))./1u\"pc\" #creates an n-dimensional vector of radii from R to R+dr \n",
    "        ϕₛ = 2π *rand(StarsPerRing)\n",
    "\n",
    "        # Positions \n",
    "        vecᵣ = (Rotation * ([rₛ.*cos.(ϕₛ),rₛ.*sin.(ϕₛ),zeros(StarsPerRing)])).*1u\"pc\"\n",
    "        x = ustrip.(u\"m\",galaxy[\"center_pos\"][1].+vecᵣ[1])#here, we strip our units into our 'integrating' unitlessness because units don't really play nice in arrays of arrays\n",
    "        y = ustrip.(u\"m\",galaxy[\"center_pos\"][2].+vecᵣ[2])\n",
    "        z = ustrip.(u\"m\",galaxy[\"center_pos\"][3].+vecᵣ[3])\n",
    "\n",
    "        # Velocities\n",
    "        Tₛ = 2π * uconvert.(u\"s\",sqrt.((rₛ*1u\"pc\").^3/(G *Introoder[\"mass\"])))\n",
    "\n",
    "        Δϕ = 2π *uconvert(u\"s\",dT)./Tₛ \n",
    "\n",
    "        vecᵥ = (Rotation* [(rₛ/(uconvert(u\"s\",dT)*1u\"1/s\")).*(cos.(ϕₛ)-cos.(ϕₛ-Δϕ)),rₛ/(uconvert(u\"s\",dT)*1u\"1/s\").*(sin.(ϕₛ)-sin.(ϕₛ-Δϕ)),zeros(StarsPerRing)])*1u\"pc/s\"\n",
    "        v₁ = ustrip.(u\"m/s\",galaxy[\"center_vel\"][1].+vecᵥ[1])\n",
    "        v₂ = ustrip.(u\"m/s\",galaxy[\"center_vel\"][2].+vecᵥ[2])\n",
    "        v₃ = ustrip.(u\"m/s\",galaxy[\"center_vel\"][3].+vecᵥ[3])\n",
    "        for j ∈ 1:StarsPerRing\n",
    "            push!(galaxy[\"star_pos\"],[x[j],y[j],z[j]])\n",
    "            push!(galaxy[\"star_vel\"],[v₁[j],v₂[j],v₃[j]])\n",
    "        end\n",
    "        R += dr\n",
    "    end \n",
    "    galaxy[\"vel_scale\"]=uconvert(u\"km/s\",√(G*galaxy[\"mass\"]/(0.5*R)))\n",
    "end\n",
    "\n",
    "\n",
    "function evolve_disk(galaxy,dT=1e-4u\"yr\",N_steps=100000,frames=500)\n",
    "    divs = trunc(Int64,N_steps/frames)\n",
    "    #Integration stuff\n",
    "    dT=ustrip(u\"s\",dT)\n",
    "    rₘ=ustrip(u\"m\",galaxy[\"softening\"]*galaxy[\"radius\"])\n",
    "    Nₛ=galaxy[\"Nₛ\"]\n",
    "    \n",
    "    #Galaxy stuff\n",
    "    M = ustrip(u\"Msun\",galaxy[\"mass\"])\n",
    "    R₀ = ustrip.(u\"m\",galaxy[\"center_pos\"])\n",
    "    V₀ = ustrip.(u\"m/s\",galaxy[\"center_vel\"])\n",
    "\n",
    "    #star stuff\n",
    "    rₛ=galaxy[\"star_pos\"]\n",
    "    vₛ=galaxy[\"star_vel\"]\n",
    "\n",
    "    function Gravity(dq::Vector{Float64},q::Vector{Float64},m,t::Float64)::Vector{Float64}\n",
    "        r = q[1:3]\n",
    "        R = q[4:6]\n",
    "        ddr = ustrip(u\"m^3/s^2\",G*M*1u\"Msun\")*(R-r)/max(norm(R-r),rₘ)^3\n",
    "        ddR = [0,0,0]\n",
    "        append!(ddr,ddR)\n",
    "        return ddr\n",
    "    end\n",
    "    Integrator=[]\n",
    "    for i ∈ 1:Nₛ\n",
    "        append!(vₛ[i],V₀)\n",
    "        append!(rₛ[i],R₀)\n",
    "    end\n",
    "    for i ∈ 1:Nₛ\n",
    "        push!(Integrator,init(SecondOrderODEProblem(Gravity,vₛ[i],rₛ[i],(0,dT*N_steps)),dt=dT,SymplecticEuler()))\n",
    "    end \n",
    "    snapshot = zeros(frames,Nₛ+1,3)\n",
    "    time = zeros(frames)\n",
    "        for i ∈ 1:frames\n",
    "            for j ∈ 1:Nₛ\n",
    "                snapshot[i,j,:] =Integrator[j].u[7:9]*3.240779289444365e-20\n",
    "            end\n",
    "            snapshot[i,Nₛ+1,:] = Integrator[1].u[10:12]*3.240779289444365e-20\n",
    "            time[i]=Integrator[1].t\n",
    "\n",
    "            for j ∈ 1:divs\n",
    "                step!.(Integrator)\n",
    "            end\n",
    "        end\n",
    "    return snapshot,time \n",
    "end\n",
    "\n",
    "function gif_galaxy(data,time,Nₛ,xlimit=[0,0],ylimit=[0,0],zlimit=[0,0])\n",
    "    if ((norm(xlimit) == 0.0) || (norm(ylimit) == 0.0) || (norm(zlimit) == 0.0))\n",
    "        xlimit = [minimum(data[:,:,1]),maximum(data[:,:,1])]\n",
    "        ylimit = [minimum(data[:,:,2]),maximum(data[:,:,2])]\n",
    "        zlimit = [minimum(data[:,:,3]),maximum(data[:,:,3])]\n",
    "    end\n",
    "    @gif for i ∈ 1:length(time)\n",
    "        scatter3d(xlim=xlimit,ylim=ylimit,zlim=zlimit)\n",
    "        for j ∈ 1:Nₛ\n",
    "            scatter3d!(data[i:i,j,1],data[i:i,j,2],data[i:i,j,3], color=:red,legends=false,markersize=1.5)\n",
    "           # i > trail ? plot3d!(Rotated[j][1,1:i],Rotated[j][2,1:i],Rotated[j][3,1:i]) : nothing\n",
    "        end\n",
    "        scatter3d!(data[i:i,Nₛ+1,1],data[i:i,Nₛ+1,2],data[i:i,Nₛ+1,3], color=:black,legends=false)\n",
    "    end \n",
    "end\n",
    "\n",
    "function gif_two_galaxies(data,time,N₁,N₂,xlimit=[0,0],ylimit=[0,0],zlimit=[0,0])\n",
    "    if ((norm(xlimit) == 0.0) || (norm(ylimit) == 0.0) || (norm(zlimit) == 0.0))\n",
    "        xlimit = [minimum(data[1:5,:,1]),maximum(data[1:5,:,1])]\n",
    "        ylimit = [minimum(data[1:5,:,2]),maximum(data[1:5,:,2])]\n",
    "        zlimit = [minimum(data[1:5,:,3]),maximum(data[1:40,:,3])]\n",
    "    end\n",
    "    @gif for i ∈ 1:length(time)\n",
    "        scatter3d(xlim=xlimit,ylim=ylimit,zlim=zlimit)\n",
    "        for j ∈ 1:N₁\n",
    "            scatter3d!(data[i:i,j,1],data[i:i,j,2],data[i:i,j,3], color=:red,legends=false,markersize=1)\n",
    "        end\n",
    "        for j ∈ 1:N₂\n",
    "            scatter3d!(data[i:i,N₁+j,1],data[i:i,N₁+j,2],data[i:i,N₁+j,3], color=:blue,legends=false,markersize=1)\n",
    "           # i > trail ? plot3d!(Rotated[j][1,1:i],Rotated[j][2,1:i],Rotated[j][3,1:i]) : nothing\n",
    "        end\n",
    "        scatter3d!(data[i:i,N₁+N₂+1,1],data[i:i,N₁+N₂+1,2],data[i:i,N₁+N₂+1,3], color=:black,legends=false)\n",
    "        scatter3d!(data[i:i,N₁+N₂+2,1],data[i:i,N₁+N₂+2,2],data[i:i,N₁+N₂+2,3], color=:black,legends=false)\n",
    "        print(i/length(time),\"% done\",end=\"\")\n",
    "    end \n",
    "end\n",
    "\n",
    "function evolve_two_disks(primary,secondary,dT=1e-4u\"yr\",N_steps=100000,frames=500)\n",
    "    #Integration stuff\n",
    "    divs = trunc(Int64,N_steps/frames)\n",
    "    dT=ustrip(u\"s\",dT)\n",
    "    r₁ₘ,r₂ₘ=ustrip(u\"m\",primary[\"softening\"]*primary[\"radius\"]),ustrip(u\"m\",secondary[\"softening\"]*secondary[\"radius\"])\n",
    "    N₁ₛ,N₂ₛ=primary[\"Nₛ\"],secondary[\"Nₛ\"]\n",
    "    \n",
    "    #Galaxy stuff\n",
    "    M = [ustrip(u\"Msun\",primary[\"mass\"]),ustrip(u\"Msun\",secondary[\"mass\"])]\n",
    "    R₁,R₂ = ustrip.(u\"m\",primary[\"center_pos\"]),ustrip.(u\"m\",secondary[\"center_pos\"])\n",
    "    V₁,V₂ = ustrip.(u\"m/s\",primary[\"center_vel\"]),ustrip.(u\"m/s\",secondary[\"center_vel\"])\n",
    "\n",
    "    #star stuff\n",
    "    r₁,r₂=primary[\"star_pos\"],secondary[\"star_pos\"]\n",
    "    v₁,v₂=primary[\"star_vel\"], secondary[\"star_vel\"]\n",
    "\n",
    "\n",
    "    function Gravitus(dq::Vector{Float64},q::Vector{Float64},m::Vector{Float64},t::Float64)::Vector{Float64}\n",
    "        pegnor= q[1:3]\n",
    "        R₁,R₂= q[4:6],q[7:9]\n",
    "        ddpegnor = ustrip(u\"m^3/s^2\",G*m[1]*1u\"Msun\")*(R₁-pegnor)/max(norm(R₁-pegnor),r₁ₘ)^3+ustrip(u\"m^3/s^2\",G*m[2]*1u\"Msun\")*(R₂-pegnor)/max(norm(R₂-pegnor),r₂ₘ)^3\n",
    "        ddR₁ = ustrip(u\"m^3/s^2\",G*m[1]*1u\"Msun\")*(R₂-R₁)/max(norm(R₁-R₂),r₁ₘ)^3\n",
    "        ddR₂ = -ddR₁\n",
    "        append!(ddpegnor,ddR₁,ddR₂)\n",
    "        return ddpegnor\n",
    "    end\n",
    "    \n",
    "    Integrator=[]\n",
    "    for i ∈ 1:N₁ₛ\n",
    "        append!(v₁[i],V₁,V₂)\n",
    "        append!(r₁[i],R₁,R₂)\n",
    "    end\n",
    "    for i ∈ 1:N₂ₛ\n",
    "        append!(v₂[i],V₁,V₂)\n",
    "        append!(r₂[i],R₁,R₂)\n",
    "    end\n",
    "    \n",
    "    for k ∈ 1:N₁ₛ\n",
    "        push!(Integrator,init(SecondOrderODEProblem(Gravitus,v₁[k],r₁[k],(0,N_steps*dT),M),dt=dT,SymplecticEuler()))\n",
    "    end\n",
    "    \n",
    "    for i ∈ 1:N₂ₛ\n",
    "        push!(Integrator,init(SecondOrderODEProblem(Gravitus,v₂[i],r₂[i],(0,N_steps*dT),M),dt=dT,SymplecticEuler()))\n",
    "    end \n",
    "    snapshot = zeros(frames,N₁ₛ+N₂ₛ+2,3)\n",
    "    time = zeros(frames)\n",
    "        for i ∈ 1:frames\n",
    "            for j ∈ 1:N₁ₛ\n",
    "                snapshot[i,j,:] =Integrator[j].u[10:12]*3.240779289444365e-20\n",
    "            end\n",
    "            for j ∈ 1:N₂ₛ\n",
    "                snapshot[i,N₁ₛ+j,:] =Integrator[N₁ₛ+j].u[10:12]*3.240779289444365e-20\n",
    "            end\n",
    "            snapshot[i,N₁ₛ+N₂ₛ+1,:] = Integrator[1].u[13:15]*3.240779289444365e-20\n",
    "            snapshot[i,N₁ₛ+N₂ₛ+2,:] = Integrator[1].u[16:18]*3.240779289444365e-20\n",
    "            time[i]=Integrator[1].t * ustrip(u\"Myr\",1u\"s\")\n",
    "            for j ∈ 1:divs\n",
    "                step!.(Integrator)\n",
    "            end\n",
    "        end\n",
    "    return snapshot,time \n",
    "end\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "([25.63397086507596 25.525919805743893 … 25.0 -4.999999999999999; 25.30235694508242 25.40889889790009 … 24.88493196428979 -4.9769760591439045; … ; -1.441677613737037 -67.32622314405052 … -5.799951886747279 -1.6291883797782363; -1.6985904973121442 -67.97237686712232 … -5.847023101537708 -1.6741612598419198;;; -24.68970781446888 -25.127942086120022 … -25.0 4.999999999999999; -24.275586049613356 -24.602994068404477 … -24.88493196428979 4.9769760591439045; … ; 0.7895893793090384 12.588807417670902 … 5.799951886747279 1.6291883797782363; 0.29496746183047917 12.707782120916043 … 5.847023101537708 1.6741612598419198;;; -4.999999999999999 -4.999999999999999 … -4.999999999999999 0.9999999999999999; -4.999987222332642 -4.999987565088087 … -4.999997411272445 0.9999974112724458; … ; -13.55537180309416 19.12772361356954 … 10.348755651576777 -14.348755651576768; -13.976966999495161 19.33235699878442 … 10.454278177451153 -14.454278177451142], [0.0, 1.5, 3.0, 4.5, 6.0, 7.5, 9.0, 10.5, 12.0, 13.5  …  435.0, 436.5, 438.0, 439.5, 441.0, 442.5, 444.0, 445.5, 447.0, 448.5])"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Target = format_parameters([5e10, 10, [-5,5,1], [15,-15,0], [1,-1,2^0.5], 10, 4000, 0.025])\n",
    "Introoder = format_parameters([1e10,5,[25,-25,-5],[-75,75,0],[0,0,1],5,1000,0.025])\n",
    "init_disk!(Introoder)\n",
    "init_disk!(Target)\n",
    "data, time = evolve_two_disks(Introoder,Target,0.5u\"Myr\",1000,300)\n",
    "#data,time = evolve_disk(Target,0.05u\"Myr\",10000,300)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0033333333333333335% done0.006666666666666667% done0.01% done0.013333333333333334% done0.016666666666666666% done0.02% done0.023333333333333334% done0.02666666666666667% done0.03% done0.03333333333333333% done0.03666666666666667% done0.04% done0.043333333333333335% done0.04666666666666667% done0.05% done0.05333333333333334% done0.056666666666666664% done0.06% done0.06333333333333334% done0.06666666666666667% done0.07% done"
     ]
    }
   ],
   "source": [
    "\n",
    "#gif_galaxy(data,time,Target[\"Nₛ\"])\n",
    "gif_two_galaxies(data,time,Introoder[\"Nₛ\"],Target[\"Nₛ\"])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "Target = format_parameters([5e10, 10, [-5,5,1], [15,-15,0], [1,-1,2^0.5], 10, 40, 0.025])\n",
    "Introoder = format_parameters([1e10,5,[25,-25,-5],[-75,75,0],[0,0,1],5,60,0.025])\n",
    "init_disk!(Introoder)\n",
    "init_disk!(Target)\n",
    "r₁ₘ,r₂ₘ=ustrip(u\"m\",Introoder[\"softening\"]*Introoder[\"radius\"]),ustrip(u\"m\",Target[\"softening\"]*Target[\"radius\"])\n",
    "M = [ustrip(u\"Msun\",Introoder[\"mass\"]),ustrip(u\"Msun\",Target[\"mass\"])]\n",
    "r₁ₘ,r₂ₘ=ustrip(u\"m\",Introoder[\"softening\"]*Introoder[\"radius\"]),ustrip(u\"m\",Target[\"softening\"]*Target[\"radius\"])\n",
    "N₁ₛ,N₂ₛ=Introoder[\"Nₛ\"],Target[\"Nₛ\"]\n",
    "R₁,R₂ = ustrip.(u\"m\",Introoder[\"center_pos\"]),ustrip.(u\"m\",Target[\"center_pos\"])\n",
    "V₁,V₂ = ustrip.(u\"m/s\",Introoder[\"center_vel\"]),ustrip.(u\"m/s\",Target[\"center_vel\"])\n",
    "r₁,r₂=Introoder[\"star_pos\"],Target[\"star_pos\"]\n",
    "v₁,v₂=Introoder[\"star_vel\"], Target[\"star_vel\"]\n",
    "\n",
    "\n",
    "function Gravitus(dq::Vector{Float64},q::Vector{Float64},m::Vector{Float64},t::Float64)::Vector{Float64}\n",
    "        r₁= q[1:3]\n",
    "        R₁,R₂= q[4:6],q[7:9]\n",
    "        ddr₁ = ustrip(u\"m^3/s^2\",G*m[1]*1u\"Msun\")*(R₁-r₁)/max(norm(R₁-r₁),r₁ₘ)^3+ustrip(u\"m^3/s^2\",G*m[2]*1u\"Msun\")*(R₂-r₁)/max(norm(R₂-r₁),r₂ₘ)^3\n",
    "        ddR₁ = ustrip(u\"m^3/s^2\",G*m[1]*1u\"Msun\")*(R₂-R₁)/max(norm(R₁-R₂),r₁ₘ,r₂ₘ)^3\n",
    "        ddR₂ = -ddR₁\n",
    "        append!(ddr₁,ddR₁,ddR₂)\n",
    "        return ddr₁\n",
    "end\n",
    "\n",
    "\n",
    "Integrator=[]\n",
    "for i ∈ 1:N₁ₛ\n",
    "    append!(v₁[i],V₁,V₂)\n",
    "    append!(r₁[i],R₁,R₂)\n",
    "end\n",
    "for i ∈ 1:N₂ₛ\n",
    "    append!(v₂[i],V₁,V₂)\n",
    "    append!(r₂[i],R₁,R₂)\n",
    "end\n",
    "for k ∈ 1:N₁ₛ\n",
    "    push!(Integrator,init(SecondOrderODEProblem(Gravitus,v₁[k],r₁[k],(0,100.123),M),dt=1,IRKN4()))\n",
    "end\n",
    "\n",
    "for i ∈ 1:N₂ₛ\n",
    "    push!(Integrator,init(SecondOrderODEProblem(Gravitus,v₂[i],r₂[i],(0,100.123),M),dt=0.1,SymplecticEuler()))\n",
    "end \n",
    "for i ∈ 1:100\n",
    "    step!.(Integrator)\n",
    "end"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cosθ = normalize(Introoder[\"normal\"])\n",
    "Rotation = rand(3,3)\n",
    "R = Introoder[\"softening\"] * Introoder[\"radius\"]\n",
    "dr = (1-Introoder[\"softening\"]) * Introoder[\"radius\"]/Introoder[\"Nᵣ\"] # Disregarding the softening, this is just the width of the rings(raidus/number of slices)\n",
    "StarsPerRing = trunc(Int64,Introoder[\"Nₛ\"]/Introoder[\"Nᵣ\"])\n",
    "rₛ = (R * ones(StarsPerRing) + dr *rand(StarsPerRing))./1u\"pc\" #creates an n-dimensional vector of radii from R to R+dr \n",
    "ϕₛ = 2π *rand(StarsPerRing)\n",
    "cosθ = normalize(Introoder[\"normal\"])[3]\n",
    "        sinθ = √(1-cosθ^2)\n",
    "        u = [0,0,1] × normalize(Introoder[\"normal\"])\n",
    "        u = normalize(u)\n",
    "\n",
    "        Rotation = [\n",
    "        u[1]*u[1]*(1-cosθ)+cosθ u[1]*u[2]*(1-cosθ)-u[2]*sinθ u[1]*u[3]*(1-cosθ)+u[1]*sinθ;\n",
    "\n",
    "        u[2]*u[1]*(1-cosθ)+u[3]*sinθ u[2]*u[2]*(1-cosθ)+cosθ u[2]*u[3]*(1-cosθ)-u[1]*sinθ;\n",
    "\n",
    "        u[3]*u[1]*(1-cosθ)+u[2]*sinθ u[3]*u[1]*(1-cosθ)+u[1]*sinθ u[3]*u[3]*(1-cosθ)+cosθ\n",
    "        ]\n",
    "        vecᵣ =Rotation.*[rₛ.*cos.(ϕₛ),rₛ.*sin.(ϕₛ),zeros(StarsPerRing)].*1u\"pc\"\n",
    "        Introoder[\"center_pos\"][1] .+ vecᵣ[1]\n",
    "        #Tₛ = 2π *sqrt.(((rₛ*1u\"pc\")^3)/(G *galaxy[\"mass\"]))\n",
    "   uconvert.(u\"s\",sqrt.((rₛ*1u\"pc\").^3/(G *Introoder[\"mass\"])))\n",
    "   dT=1E-4u\"yr\"\n",
    "uconvert(u\"s\",dT)\n",
    "Introoder[\"center_pos\"][1].+vecᵣ[1]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.8.5",
   "language": "julia",
   "name": "julia-1.8"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.8.5"
  },
  "orig_nbformat": 4,
  "vscode": {
   "interpreter": {
    "hash": "c347c8f9a7ef94e4c9e03b4513be7835ed18f45b99a2a817fb579f408b867b16"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
